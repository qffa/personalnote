# 事件循环


**JS 模型**

JS 是单线程非阻塞模型

javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务（调用栈中）


web worker


## JS内存模型

**JS 运行时**

- 栈 Stack
- 堆 Heap
- 队列 Queue


**栈**

函数调用形成了一个由若干帧组成的栈

即调用栈（执行栈）

**堆**

对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语

**队列**

也叫 Callback Queue / Task Queue / 事件队列

待处理的 消息 的队列，先进先出

每一个消息都关联着一个用以处理这个消息的回调函数


##消息

【每一个消息完整地执行后，其它消息才会被执行】

在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列
如果没有事件监听器，这个事件将会丢失

也就是事件发生之后，与事件绑定的回调函数才会放入 事件队列，等待执行。他说的消息基本上可以认为是回调函数



## 事件循环

**event loop**

在 事件循环 期间的某个时刻，调用栈空了，运行时会从最先进入队列的消息开始处理队列中的消息，取出第一个消息

处理的消息会被移出队列，并作为输入参数来调用与之关联的函数，也就是放入调用栈

调用一个函数总是会为其创造一个新的栈帧

函数的处理会一直进行到执行栈再次为空为止



**异步执行**

当有代码需要异步执行时，如 I/O 事件，它的回调函数会被放入队列等待，直到 I/O 操作事件结束，回调函数
放到 事件队列 等待执行


**执行至完成**

当一个函数执行时，它不会被抢占

只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据

缺点：当一个消息需要太长时间才能处理完毕时，Web应用程序就无法处理与用户的交互，例如点击或滚动

**例外**

如 alert 或者同步 XHR，但应该尽量避免使用它们


## 微任务与宏任务

微任务（micro task）和宏任务（macro task）

以下事件属于宏任务：

- setInterval()
- setTimeout()

以下事件属于微任务

- new Promise()
- new MutaionObserver()


**执行机制**

运行时会先看微任务队列里是否有消息，有消息先处理，知道微任务队列为空，才会去查看宏任务队列


## node.js 中的事件循环



和浏览器中略有差别

在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。

https://zhuanlan.zhihu.com/p/33058983



图：

```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```
