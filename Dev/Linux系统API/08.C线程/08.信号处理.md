# 线程相关的信号处理

## 信号处理方式

所有的线程共享相同的信号处理方式

如果其中某个次线程改变了该信号的处理方式，那么所有的线程将共享这一改变

## 信号屏蔽字和未决信号字

**没有次线程时**

此时整个进程只有一个主线程，整个进程的“信号屏蔽字”和“未决信号字”，就是主线程的“信号屏蔽字”
和“未决信号字”。

**有次线程时**

每个次线程都有自己独立的“信号屏蔽字”和“未决信号字”，次线程的“信号屏蔽字”和“未决信号字”是从主线程
的“信号屏蔽字”和“未决信号字”复制而来

- 次线程的“信号屏蔽字”会保留从主线程“信号屏蔽字”所复制的值
- 次线程的“未决信号字”会清空，也就是说不会保留所复制值

如果次线程对某些信号有特殊的“响应需求”的话，可以自己调用如下函数，修改次线程自己的“信号屏蔽字”，
以实现将某个信号打开或者屏蔽。

```
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

总结： 由于有多个线程存在，进程可以挑选任意一个线程去响应某个信号

## 多线程时的信号响应

1. 进程收到信号后，进程会找到某一个没有屏蔽该信号的线程去处理在这个信号

2. 如果所有的线程都屏蔽了该信号的话，信号发生时，进程会将未决信号记录到某个线程的“未决信号字”中

3. 当线程收到进程判给它的信号后，而且如果该信号的处理方式还是捕获的话
    这个线程在运行时会被中断，然后去执行信号捕获函数，当信号捕获函数执行完毕后，才会
    返回被中断的线程，接着执行。
