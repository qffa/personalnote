# 程序的内存结构

内存结构，或者称内存布局，就是程序存储在内存中运行时，程序所占用的存储空间的结构，也可以被称为“存储映像”。

裸机和基于OS虚拟内存运行时的程序布局几乎差不多，二者最基本的组成都是 = 代码段 + 静态数据段 + 堆 + 栈。

## OS虚拟内存中的应用空间

```
+---------------------+ 0xffffffff
|                     |
+---------------------+
|                     |
|                     |
|    kernel space     |
|                     |
|                     |
+---------------------+
|       stack         |
|         ↓           |
|                     |
|                     |
|       share         |
|                     |
|                     |
|         ↑           |
|        heap         |
+---------------------+
|      .bss           |
+---------------------+
|      .data          |
+---------------------+
|      .rodata        |
+---------------------+
|      .text          |
+---------------------+
|      .init          |
+---------------------+
|      段头部表        |
+---------------------+
|     ELF Header      |
+---------------------+ 0x08048000
|                     |
+---------------------+ 0x00000000
```

说明

- 静态数据段：`.bss`, `.data`
- 动态数据段：`stack`, `heap`, `shared area`
- 代码段：`.init`, `.text`, `.rodata`, `ELF Header`, `Segment Headers Table`


**裸机与基于OS的区别**

- 运行地址不同，裸机是物理地址，基于OS时是虚拟地址
- 基于OS时，进程的虚拟内存空间分为了内核空间和用户空间
- 基于OS时，堆和栈之间还有一个共享映射区，用于共享库、进程间通信等等

## 指令与数据的存放

程序在内存中存储时，就存储两种东西，

- 指令
- 数据

**指令**

指令存储在代码段中的`.init`和`.text`节

- `.init`节：存放启动代码相关指令
- `.text`节：存放我们自己所写的程序指令

**数据**

数据的存储有两种形态

- 数据存储在常量空间（`.text`, `.rodata`）
- 数据存储在变量空间（`.data`, `.bss`, 栈, 堆）

**常量**

常量空间要求是只读的，在程序的内存布局中，只有代码段是只读的，所以常量空间开辟在`.text`和`.rodata`中

- `.text`中，常量作为指令的一部分存储在`.text`中，例如`a=a+100`中的`100`
- `.rodata`中，字符串常量通常存放在`.rodata`中，例如`printf("hello")`中的`hello`

**变量**

变量空间只能开辟在数据段中，因为只有数据段是可写的。变量分为两种：

- 静态变量：开辟于静态数据段（`.data`, `.bss`）
- 动态变量：开辟于动态数据段（堆、栈）

**静态变量**

编译时决定

- `.data`中：存放初始化了的全局变量和静态局部变量（用`static`修饰的函数内部变量）
- `.bss`中：存放未初始化的全局变量和静态局部变量

在“可执行目标文件”中，`.bss`并不存在，程序加载后才会开辟`.bss`的空间， 然后再在`.bss`里面开辟未初始化静态变量的空间，并自动初始化为`0`。

**动态变量**

之所以称之为动态的，是因为变量空间并不是在编译时决定的，而是在程序运行时才有的。动态变量分为两种：

- 自动局部变量：没有`static`修饰的函数局部变量，以及函数形参，空间开辟在**栈**中
- 手动开辟的变量：使用`malloc`函数开辟的变量，空间开辟在**堆**中

**开辟堆变量**

```
int main(void){
        int *p = NULL;

        p = malloc(4);  //在堆中开辟4个字节空间
        if(p == NULL){
                printf("malloc fail\n");
                exit(-1);  //空间开辟失败，结束进程
        }

        bzero(p, 4);  //将开辟的空间清零
        *p = 100;  //使用开辟的空间

        free(p);  //释放p所指向的空间
}
```
说明

- 新开辟出来堆、栈空间，里面的值是随机值。
- 从栈、堆中开辟变量时，为了避免随机值带来的问题，**一定要初始化**
