# 重定位

链接器在完成了符号解析之后，就可以进行重定位了。 重定位本身比较复杂，以下只是基本内容。

## 重定位的种类

**动态重定位**

动态重定位就是，重定位的动作是在程序运行的过程中动态完成的，因此被称为动态重定位。

**静态重定位**

所谓静态重定位就是，由链接阶段完成的重定位，因为是在程序运行之前做的重定位，因此被称为静态重定位

## 静态重定位

静态重定位完成的两件事

- 将同名节整合成新的同名聚合节
- 将各个聚合节的地址，重定位为实际的运行地址

**整合聚合节**

其中重点是将`.text`和`.data`节聚合为新的同名聚合节，为了能够将`.text`和`.data`节聚合为新的聚合节， 需要依赖一些信息，这些信息存储在了`.rel.text`和`.rel.data`中。

**重定位为运行地址**

就是将程序在内存中实际运行时的内存地址赋给聚合节，程序在内存中运行时，就是按照重定位的地址来运行

1. 裸机情况下（没有OS），程序是直接运行在物理内存上的，所以重定位的运行地址就是物理地址，所以CPU取指时所取得的指令地址就是物理地址。

2. 基于OS运行情况下，大部分的OS都有提供虚拟内存机制，所以程序是运行在OS虚拟内存上的，虚拟内存所提供的地址就是虚拟地址，所以CPU取指时，所取得的指令地址就是虚拟地址。

**指定重定位运行地址**

运行地址是通过“链接脚本文件”来指定的，“链接脚本文件”里面会说明实际的运行地址是多少，重定位时会把把实际的运行地址赋值给新的聚合节，如此一来，函数和全局变量就有了真正可以运行的运行地址

实际运行时，将程序拷贝到运行地址所指定的内存位置，cpu的pc存放第一条指令地址(指向第一条指令`_start`)，然后整个程序就运行起来了。

## 运行地址

**裸机情况**

运行地址（物理地址）是多少，可以由程序员自己来决定，比如指定为`0`，表示程序需要拷贝到物理内存的`0`地址处，从`0`地址处开始存放。

将0地址写到链接脚本文件中，gcc编译时给他指定链接脚本，重定位后运行地址就从`0`开始。

**基于OS运行**

运行地址（虚拟地址）为一个固定值，不同OS这个固定值不一样，比如在Linux这边

- 32位OS：从`0x08048000`开始
- 64位OS：从`0x0000000000400000`开始

程序运行时，程序会被拷贝到虚拟内存的`0x08048000`或者`0x0000000000400000`位置处，然后pc指向`_start`，程序就运行起来了

这个地址也是指定在链接脚本中，只不过不需要我们自己指定
