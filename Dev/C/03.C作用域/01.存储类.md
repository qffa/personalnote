# 存储类

存储类的全称叫“存储类型”，存储类就是用来说明“常量、变量和函数”的存储位置的。

## Linux下C的内存映像

**代码段**

1. ELF头
2. 段头部表
3. `.init`节
4. `.text` 指令节
5. `.rodata` 常量节

**数据段**

1. 静态数据段
    - `.bss`节，未初始化的静态变量
    - `.data`节，初始化了的静态变量
2. 动态数据段
    - 堆（手动区）
    - 栈（自动区）

**静态的含义**

在`.bss`, `.data`中为哪些变量开辟空间，是由编译器在编译时决定的，在程序运行的过程中不能随意开辟， 也不能随意释放已有变量的空间，像这种在编译阶段完成了变量空间安排的情况，就是静态的

## 存储类说明

**函数指令**

`.text` 函数指令存放在`.text`中

**常量**

`.text` 小到能够和指令放在一起的话，就会和指令一起直接放在`.text`中
`.rodata` 常量比较大时，就是放在`.rodata`中

**全局变量**

`.data` 初始化了的全局变量
`.bss` 未初始化的全局变量

**自动局部变量**

存储于栈中
```
int fun (void) {
    auto int a; //等价于 int a, auto可以省略不写
    ...
}
```
其实这个`auto`关键字主要是给编译器用的，因为编译器必须通过这个关键字来识别“栈”这个存储类， 就算`auto`被省略了，但是在编译时会被自动加，用以标记局部变量是“栈”这种存储类。

**静态局部变量**

`.data` 初始化了的静态局部变量
`.bss` 未初始化的静态局部变量

```
int fun (void) {
    static int a = 10; // 存储于.data中
    static int b;  // 存储于.bss
    ...
}
```
静态局部变量的作用：函数退出，数据依然有效。下次函数调用还可以使用这个数据

静态变量：由于全局变量与静态局部变量的存储类都是静态数据段，因此我们就将全局变量和静态局部变量统称为静态变量。

**寄存器变量**

```
int fun (void) {
    register int a; // 变量a存储在cpu寄存器中
    ...
}
```

使用场景

- 某个局部变量需要访问速度非常快
- 某个局部变量使用频次非常高

注意

- 虽然写了`register`，但不一定有效。如果cpu的寄存器数量很少， 比如intel cpu的寄存器数量相对ARM CPU来说就偏少， 所以很有可能出现寄存器不够用的情况，如果编译器编译时发现寄存器不够用了， 编译器就会将`register`自动改为`auto`。

- 就算你不写`register`，以优化方式编译时，编译器也可能会帮你自动改为`register`。如`gcc a.c -O1`

- 优化有好处，自然也有缺点，最大的缺点就是自作主张修改你的代码，让原有的代码逻辑发生改变， 甚至有时完全违背了你的原意，所以如果你不想被优化的话，建议编译时就不要指定优化选项。

**形参**

形参存储于栈中，实际上可以将它看作是局部变量

- `auto`, `static`不可以修饰形参，因为形参默认存储类就是栈
- `register`可以修饰形参，可以让形参进寄存器
- ARM cpu寄存器特别丰富，在ARM上编译c时，默认前4个函数的形参都会进寄存器

**其他**

- `auto`, `register`不可以修饰全局变量。全局变量存储类编译时就确定好了，在静态数据区
- `static`可以修饰全局变量，但是与存储类无关，只与链接域有关
