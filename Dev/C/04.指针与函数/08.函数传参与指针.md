# 函数传参与指针

## 函数的两种传参方式

**传值**

传值，即普通传参，其实就是开辟一个形参空间，然后将实参数据复制过去，此时形参是独立的变量空间，修改形参时，实参不会有任何改变。

**传引用**

传引用，即传递指针，把指针传递到函数内，对指针解引用可以实现对实参访问和修改。

```
#include <stdio.h>

int fun (int *p) {
    *p *= 2;
    return *p;
}

int main (void) {
    int a = 10;
    fun(&a);

    printf("%d\n", a);  // a的值为20
    return 0;
}
```

## 传递指针的原则

**修改原则**

被调函数需要修改实参的值

**效率原则**

实参是一片空间，如结构体、属组、函数等

**另外**

只需要普通传参即可搞定的，就不要传递指针。

## 控制形参数量

只有当有必要时才传参。要尽量控制形参数量，避免不必要的栈空间浪费。
如果参数非常多，可以将参数封装进结构体，然后传入结构体指针。

## 函数参数不确定的情况

两种情况

- 参数数量不确定
- 参数类型不确定

**参数类型不确定**

此时可以使用`void *`型指针传参

```
#include <stdio.h>

struct student {
    int num;
    char name[40];
    float score;
};

void fun (int type, void *p) {
    if (type == 0) {
        printf("%d\n", (int *)p);
    }
    else if (type == 1) {
        *((float *)p) = 1.234;
    }
    else if(type == 2) {
        struct student *tmp = (struct student *)p;

        printf("%d\n", tmp->num);
        printf("%s\n", tmp->name);
        printf("%f\n", tmp->score);
    }
}

int main (void) {
    struct student stu = {1234, "libai", 99};

    fun(2, (void *)&stu);
}
```

## 传递指针的风险

为了提高传参效率，所以必须传递指针，但是并不想修改实参的内容，但是由于传递的是指针，所以存在潜在误改实参的风险。

**规避指针风险**

- 使用普通传参
- 如果必须传递指针可以使用`const`来防止误修改

## 函数执行结果的返回

**使用返回值返回**

使用`return`返回结果。如果返回值类型不确定，可以返回`void *`型

**通过指针参数返回**

将接收函数返回值的变量指针传入函数，函数直接将结果写入指针指向的空间。

库函数和OS API中，`return`的返回值往往用于说明函数是否调用成功，一般返回`0`表示调用成功，返回`-1`表示调用是失败。返回计算结果使用指针传参方式返回。
