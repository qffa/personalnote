# 指针

指针即地址，地址即指针。存放指针的变量即指针变量。

## 取地址

取地址运算符为`&`

**取变量地址**

```
int a = 100;

// &a 为变量a的第一个字节的地址，即a的指针
```

**取函数地址**

```
int fun () {
  ...
}

// &fun为函数指针，即函数代码所在空间第一个字节的地址
```
取函数指针时`&`可以省略，因为函数名可以代表函数指针，即`fun`与`&fun`等价。

**取数组地址**

```
int buf[7] = {0};

// &buf为整个数组的地址，类型为int (*)[7]
// &buf[0]为数据第一个元素的地址，类型为int *
// buf也指代&buf[0]
```

**另外**

`&`作为双目运算符使用时为位与运算符

## 解引用

解引用运算符`*`

**解引用**

```
int a = 100;
int *p = &a;

*p = 200;    // *p，解引用
```

说明

- 整个`*p`代表就是`p`中指针所指向的空间，也就是`a`的空间，所以`*p=200`与`a=200`的效果是一样的。此时`*`的作用就是解引用，解引用时`*p`是一个整体。

- 使用`*`解引用时，其实解引用的是`p`中的指针，而不是`p`本身，`p`只是装指针的容器。


**构建指针类型**

`*`与`char`, `int`, `float`, `struct Student`等类型相结合，构成指针类型。如`int *p`

## 获取地址

**直接使用地址**

```
int *p = (int *)0x4234f5e4;
*p = 200; //向0x4234f5e4所指向的空间，写入200
```

前提

- 地址对应的空间存在
- 这个空间没有被别人（变量、常量、代码）使用
- 空间的访问权限，能够满足我们的访问要求

一般在单片机、驱动等偏硬件的c程序中才会直接使用数字形式的地址

**使用取地址运算符**

```
int a;
int *p = &a;
*p = 200;
```

`a`不是指针，`a`只是一个符号，`&a`才是`a`的指针

**使用malloc返回的地址**

```
int *p = malloc(4)
```

`malloc`从堆中开辟空间后，返回指针

**某些符号本身就是地址**

- 字符串常量 `char *p = "hello wolrd，it is butefull"`
- 函数名即指针
- 数组名即数组第一个元素指针 `int buf[10]`, `buf` = `&buf[0]`

## 解引用方式

**直接解引用**

直接对地址解引用

```
*((int *)0x43355435) = 100;

int a;
*(&a) = 200;
```


**间接解引用**

先放到指针变量中，然后通过指针变量去使用。

```
int a = 10;
int *p = &a;

*p = 200;  
```

`&` 和 `*`互为逆运算，`*p = 200`实际上就等价于`*&a = 200`。其实相当于`*`和`&`相互抵消了。

## 指针的其他内容

**指针变量的大小**

- 指针变量的大小是固定的，等于位宽（32位或64位）
- `sizeof`运算符查看指针变量的大小，例如`sizeof(int *)`,

**指针的类型**

- 指针类型由基本类型 + `*`组成。例如：`int *`, `char *`
- 其中基本类型用于确定指针解引用时，对数据的解释方式。

**定义指针变量**

在指针类型后加上变量名即可。例如：`int *p`, `int **p`

**指针类型强制转换**

```
float *p1 = &a;  //隐式强制转换
float *p2 = (float *)&a;  //显示强制转换
```

此时指针并没有改变，只是指针指向空间的解释方式变了。
慎重使用强转！！
