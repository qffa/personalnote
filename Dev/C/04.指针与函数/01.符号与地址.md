# 存储空间、符号和地址

## 存储空间

**存储空间的概念**

存储空间就是程序代码和数据的存放空间。没运行时，在硬盘上，运行后在内存里，供cpu访问

**访问存储空间**

存储器的每一个字节都有地址，这个地址就是每个字节的门牌号，通过地址就能找到每一个字节并访问它

## 地址与指针

**地址**

每个字节的编号即地址。地址总线的位宽决定地址可以是多少位的。
32位寻址范围：`0x00000000` ~ `0xFFFFFFFF`

**指针**

指针就是地址，地址就是指针。

**指针变量**

存放地址的变量

```
int a;
int *p = &a;
*p = 100
```

`&a`： `a`的指针，`a`有四个字节，第一个字节的地址为`a`的指针
`p`： 存放地址（指针）的变量
`&`： 取地址，取地址取的是变量的地址
`*`： 解引用，解引用解的是变量空间里面的指针

**符号与地址**

在高级语言里面，地址都被替换为了符号。比如我使用某个变量空间，在高级语言里面，就通过变量名来访问，变量名就是一个符号，通过这个符号就可以操作这个变量，不必直接使用地址。

所以在高级语言的程序里面，程序员基本只见符号，不见地址，正是由于这样的做法，使得高级语言的语法相对汇编来说，非常的人性化。

编译后，符号虽然会被转化为地址，但是在高级语言的语法里面，符号并不直接等于地址，你不能直接当做地址来使用，在高级语言里面，符号会受到作用域的限制，缺少一定的灵活性。

所以为了能够更加自由的操作存储空间，像c/c++这种高级语言，除了能够使用符号来操作外，它还允许直接使用地址来操作，使用地址来操作时，可以不受符号作用域的限制。

## 内存字节空间

代码、变量、常量空间，往往都是连续的一片字节空间。第一个字节的地址是整个空间的指针。

**访问字节空间**

- 知道第一个字节的地址
- 知道访问到第几个字节结束
- 知道如何解析里面存放的数据

**例子**

访问`int`变量空间

- 知道第一个字节地址，即指针
- `int`大小为四个字节
- 数据类型为整形，访问空间时，按照整形存储结构去解析空间

## C语言数据类型

**整形**

- char
- short
- int
- long

**浮点**

- float
- double

**组合类型**

- 结构体
- 联合体
- 指针

**数据类型的意义**

- 编程时容易识别
- 数据类型决定了空间大小和存储结构
- 编译器可以检查类型错误

**赋值语句类型匹配问题**

等号的左边叫左值，右边叫右值，不管`=`是用于初始化，还是用于赋值，要求右值必须与左值类型一致。

- 天然一致，`int a = 100`
- 强行一致，`int a = (int)100.121`

## 类型强制转换

**显式强制转换**

```
int a = (int)12.5;

float a = 100.0;
int b = (int)a;

int a = 45;
int b = (int)&a;
```

**隐式强制转换**

编译器在编译时，会默认将右值类型强制转换左值的类型，这就是隐式强制转换。

```
int a = 12.56;
float 12.56被隐式转为int后，再给a

int a = 12.56;
char b = a;
int a被隐式转为char后，在都给b

int a = 10;
char *p = a;
int被隐式转为char *

int a = 10;
char *p = &a;
int *被隐式强制转为char *
```

建议

- 像`int a = 12.56`这种基本类型的隐式强制转换，编译器在编译时是不会报警告的，但是像指针这种很重要的类型，编译时一定会报警告提醒你，两边类型不一致，让你警惕，因为编译器很担心这是你的误写。

- 尽量不要使用隐式强制转换，如果确实需要进行“强制转换”，我们应该使用`(` `)`进行显式强制转换，显式强制转换的目的

## 函数的传参与返回值

**传参**

编译器翻译传参时，其实就是赋值，等效有一个=存在
形参 = 实参，形参为左值，实参为右值
如果传参时类型不一致的话，最好使用显式强制转换，不要使用隐式的。

**返回值**

返回值与返回类型要一致，否则要强转，我们最好使用显式强制转换，不要使用隐式的。

```
int fun (void) {
    ...
    return (int) 12.345;
}
```

**强制转换时到底发生了什么**

*预留*
