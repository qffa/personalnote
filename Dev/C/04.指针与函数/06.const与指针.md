# const与指针

`const`是constant的缩写，为常量的意思，所以当变量被`const`修饰后就变为了常量。
不过这个“常量”并不是真正的常量，而是一个伪常量。


**const修饰普通变量**

使用`const`修饰后，只能通过初始化给值

```
int const a = 0; //等价于const int a = 0
a = 100;    		 //编译报错

int fun(const int a)
{
    printf("a = %d\n", a); //打印初始化的值

    a = 200;        //这句话无法编译通过，因为const修饰的就不能被赋值
}
```

*函数传参也是初始化*


**const修饰指针变量**

原理一样：`const`修饰哪部分，那部分就不能被赋值

```
int const *p
// *p不能被修改，即p所指向的空间不能被需改，但p本身可以被修改

int * const p
// p不能不修改，但*p不受限制

int const * const p
// p 和 *p 都不能被需改
```

**const实现原理**

- 变量被`const`修饰后，编译器会阻止对该变量的赋值语句。编译器报错并终止编译。
- 但实际上该变量还是存放在`.data`, `.bss`, 堆或者栈中。这些存储区域是可读可写的。
- 用指针还是可以修改`const`修饰的变量的
- 真正的常量是存储在`.text`或`.rodata`中的。这些存储区域，只能读不能写。

**code关键字**

开发单片机的c语言才支持
用`code`修饰之后，数据会和代码放到一起，变成真正的只读

```
int code a = 100;
```
