# 缓存问题

缓存就是程序在内存中开辟的用来存放数据的变量空间

## 三种缓存

**应用缓存**

应用代码在内存中开辟的缓存空间

**库缓存**

库代码在内存中开辟的缓存空间

**内核缓存**

内核代码在内存中开辟的缓存空间

## 数据在三种缓存中的流向

**读数据时**

1. 内核函数通过设备驱动代码，将数据从文件读到内核缓存中
2. 标准io库调用文件io函数，将数据从内核缓存读到标准io的库缓存
3. 应用代码调用标准io函数，将数据从标准io的库缓存读到应用缓存空间


**写数据时**

过程刚好相反

1. 应用代码调用标准io的写函数，将数据从应用缓存写入到标准io的库缓存
2. 标准io库调用文件io的写函数，将数据从标准io的库缓存写到内核缓存
3. 内核函数通过设备驱动代码，将数据从内核缓存交个设备，例如显示器、硬盘

## 库缓存的三种缓存方式

**无缓冲**

无缓冲就是，只要库缓存中有了数据就立即刷新，哪怕只有一个字符，也会立即刷新，数据是不会积压的。

无缓冲非常适合用于输出错误信息，因为出错信息很紧急，不能被积压，所以有了错误信息后就应该被立即无条件刷新输出。

stderr（标准出错输出）就是专门用来输出错误信息的，所以就是“无缓冲”的情况。

**行缓冲**

数据会积压，直到“满一行”时才会刷新，然后将数据输入/输出。`\n`就是一行的判断条件，只要数据中有`\n`，就代表数据满一行了。

行缓冲非常适合用于正常的键盘输入和打印显示（正常的人机交互），人与计算机的交互就跟人与人的说话一样，一句一句的来是最方便的，这样既不会因为说话太急而累到，也不会出现等很久都得不到信息的情况。

人机交互时一行其实就是一句，stdin、stdout（标准输入、标准输出）就是专门用来进行正常人机交互用的，所以都是行缓冲的，满足一行的条件时就会立即刷输入、输出数据。

按照c标准的规定，stderr为无缓冲，stdin、stdout为行缓冲，但是针对不同平台的“标准io库”在实现时，不一定都会严格的准守c标准，比如：
- 在Linux下：stderr为“无缓冲”、stdin、stdout为“行缓冲”，准守了c标准的规定
- 在Windows下：stderr、stdin、stdout都是无缓冲，只要库缓存有数据就会立即刷新。

**全缓冲**

特点是必须等到“库缓存”的空间，全部被数据积压满后，才会输出。

读写硬盘上普通文件时就是“全缓冲”，比如以写为例，写普通文件时由于不涉及人机交互时的“及时性”问题，所以并不需要立即写到文件中，完全可以先将大量数据积压到缓存中，等填满整个缓存之后再一次性刷新输出。

读写fopen所打开的普通文件时，就是“全缓冲”的。

## 三种缓冲的基本刷新方式

**stderr：无缓存**

只要“库缓存”中有数据就无条件立即刷新输出

```
#include <stdio.h>

void main()
{
    fprintf(stderr, "hello wolrd");
    while(1);

    return 0;
}
//hello wolrd被立即输出。
```

**stdout：行缓存**

```
void main()
{
    fprintf(stdout, "hello wolrd");
    fprintf(stdout, "@@@@@@@@@@@");
    printf("22222222222");
    fprintf(stdout, "！！！！！！！！");

    while(1); //死循环

    return 0;
}
//打印结果：无
```

由于没有`\n`，所以数据全部被积压在库缓存中，所以看不到打印结果。

**全缓冲**

```
#include <stdio.h>

int main(void)
{
    FILE *fp;
    fp = fopen("./file", "w+");
    fprintf(fp, "hello world\n");
    while(1);

    fclose(fp);

    return 0;
}
```

`fp`指向了普通文件，此时就是全缓存的，尽管`"hello world\n"`中有个一`\n`，但是全缓冲不受`\n`影响，由于数据太少，还不足以填满整个库缓存，所以无法被刷新，此时打开file.txt文件时，里面不会有数据。

此时需要使用强制刷新

## 缓冲的其他刷新方式

无缓冲是无条件立即刷新的，所以不需要什么额外刷新方式，但是行缓冲和全缓冲并不一定会立即刷新，当不满足刷新条件时，可以使用其它“刷新方式”来刷新

**手动刷新**

调用`fflush`函数手动刷新库缓存

```
#include <stdio.h>

int main(void)
{
    FILE *fp;
    fp = fopen("./file", "w+");
    fprintf(fp, "hello world\n");
    fflush(fp);  /* 手动刷新 */
    while(1);

    fclose(fp);

    return 0;
}
```

**文件关闭**

`fclose`关闭文件时，也会自动的调用`fflush`函数来手动刷新。

程序正常终止时，也会自动的调用`fclose`函数。

例如：

```
void main(void)
{
  fprintf(stdout, "hello wolrd");
  fprintf(stdout, "@@@@@@@@@@@");
  printf("22222222222");
  fprintf(stdout, "！！！！！！！！");

  return 0;
}
```

## scanf与缓存

从键盘输入数据时，不管输入什么数据，只有当敲了回车`\n`后才会输入，从键盘输入数据时，输入的最后
输入的字符一定是`\n`。

但是`scanf`等读取函数从“库缓存”里面读取数据时，往往会将`\n`留在“库缓存”里面，如果后续紧跟着
`scanf`, `fscanf`, `getc`, `getchar`等函数来读取数时，读取到的将是“库缓存”中遗留的`\n`，或者其它无用字符。

```
#include <stdio.h>

int main(void)
{
    char a;
    int b;
    char buf[10];

    char c;

    //scanf("%c", &a);
    a = getchar();
    //scanf("%d", &b);
    //scanf("%s", buf);

    //gets(buf);
    //puts(buf);

    scanf("%c", &c);
    printf("%d", c);

    return 0;
}
```

解决方法：

```
/* 循环把剩余字符读走 */
while(getchar() != '\n');
```

不过fgets、gets取数据时不存在遗留垃圾字符的问题
