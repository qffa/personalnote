# 宏与位运算

不管是在我们自己的代码中，还是在c库、os内核源码中，为了方便使用，往往会将位操作定义为“带参宏”的形式。

## 置位宏

**功能**

将某个bit置位，即置1

**例子**

```
#include <stdio.h>
#define SET_BIT(x, n) ((x) | (1<<(n)))

int main(void){


    int a = 7;
    a = SET_BIT(a, 3);

    printf("%x\n", a);

    return 0;
}
```

## 复位宏

**功能**：将某个数的某个bit复位，置0

**例子**

```
#define RESET_BIT(x, n) ((x) & (1<<(n)))

RESET_BIT(100, 4);
```

## 构建序列

构建出某些位为1，其他位位0的数

```
#define MAKE_SERI_NUM(n, m) (~((~0U)<<(m-n+1))<<(n))
int a = MAKE_SERI_NUM(4, 8);

/* 计算过程 */
~0u:            11111111111111111111111111111111
(~0u)<<(8-4+1): 11111111111111111111111111100000
~               00000000000000000000000000011111
<<4             00000000000000000000001111100000
```

## 获取数中某几位

**原理**

- 得到某几位连续位`1`，其他位全为`0`的数，使用M`AKE_SERI_NUM`宏得到
- 与这个数做`&`运算，取出关心的那连续几位
- 右移到最右边

**代码**

```
#include <stdio.h>

#define MAKE_SERI_NUM(n, m) (~((~0U)<<(m-n+1))<<(n))

#define GET_BITS(x, n, m) (((x) & MAKE_SERI_NUM(n, m)) >> (n))


int main(void){
    int a = GET_BITS(3454, 5, 8);
    printf("%d\n", a);

    return 0;

}

// 输出结果为 11
```

**分析**

```
step 1
MAKE_SERI1_NUM(5, 8)：
  00000000000000000000000111100000

step 2
((3454) & MAKE_SERI_NUM(5, 8))：
  00000000000000000000110101111110 （3454）
& 00000000000000000000000111100000
= 00000000000000000000000101100000

step 3
((3454) & MAKE_SERI_NUM(5, 8)) >> (5)：
  00000000000000000000000101100000 >> 5
= 00000000000000000000000000001011  （11）
```
