# 大小端序

## MSB 和 LSB

MSB： Most Significant Bit(最高有效位)，也就是最高位，最左侧的bit
LSB： Least Significant Bit(最低有效位)，也就是最低位，最右侧的bit

```
0x23456334
00100011 01000101 01100011 00110100
MSB --------------------------— LSB
```

## 低地址字节和高地址字节

以`int`类型数据为例，占据内存中4个字节的空间，这4个字节都有一个编号，编号小的就是低地址字节，编号大的就是高地址字节。

```
Data      Addr
00000001  0x0003    <- 低地址字节
01000000  0x0002
10101010  0x0001
01010101  0x0000    <- 高地址字节
```

## 存储大小端序

大端序：数据MSB所在的字节存储在低地址字节空间
小端序：与大端序相反，数据MSB所在字节存储在高地址字节空间

例如：MSB `00100011 01000101 01100011 00110100` LSB
```
/* 大端序 */
Data      Addr
00110100  0x0003
01100011  0x0002
01000101  0x0001
00100011  0x0000

/* 小端序 */
Data      Addr
00100011  0x0003
01000101  0x0002
01100011  0x0001
00110100  0x0000
```

##测试大小端序

```
#include <stdio.h>

union my_union {
    int inta;
    char chara;
} test;

int main (void) {
    test.inta = 0x12345678;
    printf("%x\n", test.inta);

    if (test.chara == 0x12)
        printf("big-endain\n");
    else if (test.chara == 0x78)
        printf("little-endain\n");

    return 0;
}
```

## 通信大小端序

通信时与存储无关，只与数据的传输有关，这里只考虑串行通信，因为只有串行通信才存在“通信大小端”的问题。


- 串行通信时，如果先从MSB开始发送数据，就是通信大端序。通信大端序是MSB先被发送，因此也被称为MSB先行。

- 穿行通信时，如果先从LSB开始发送数据，就是通信小端序。通信小端序是LSB先被发送，因此也被称为LSB先行。
